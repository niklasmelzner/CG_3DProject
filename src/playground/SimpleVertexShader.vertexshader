#version 420 core

#define MAX_LIGHTS=32

//https://learnopengl.com/Lighting/Materials
struct Material {
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};
//end

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;

layout(location = 1) in vec3 normalIn;

layout(location = 2) in vec3 colorIn;

layout(location = 3) in vec2 texCoordIn;

out vec3 color;

out vec3 fragPos;
out vec3 normal;
out vec3 viewPos;
out vec3 lightPos;
flat out float hasTexture;
flat out float hasMat;
out vec3 matAmbient;
out vec3 matDiffuse;
out vec3 matSpecular;
out vec2 uv;

// Values that stay constant for the whole mesh.
uniform mat4 VP;
uniform mat4 M;
uniform mat4 V;
uniform vec4 viewDirection;
uniform vec3 viewPosIn;
uniform vec3 lightPosIn;
uniform int lightSize;
uniform float hasTextureIn;
uniform float hasMatIn;
uniform Material material;

//https://learnopengl.com/Lighting/Basic-Lighting

void main(){
	hasMat=hasMatIn;
	if (hasMat==1.0){
		matAmbient=material.ambient;
		matDiffuse=material.diffuse;
		matSpecular=material.specular;
	}

	hasTexture = hasTextureIn;

	if (hasTexture==1.0){
		uv=texCoordIn;
	}else{
		color=colorIn;
	}
	
	//lightPos=lightPosIn;
	lightPos=vec3(0.0,0.0,0.0);

	// Output position of the vertex, in clip space : VP * position
	gl_Position =  VP * M * vec4(vertexPosition_modelspace,1);

	fragPos=vec3(M*vec4(vertexPosition_modelspace,1));

	mat4 normalMatrix=transpose(inverse(M));

	normal = normalize(vec3(normalMatrix * vec4(normalIn,1.0)));

	//normal=normalize(vec3(M1*vec4(normalIn,1.0)));

	//viewPos=vec3(M1*vec4(viewPosIn,1.0));
	
	fragPos=vec3(M*vec4(vertexPosition_modelspace,1.0));
	
	viewPos=viewPosIn;
    
}

